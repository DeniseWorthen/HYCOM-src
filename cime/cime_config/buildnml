#!/usr/bin/env python

"""hycom namelist creator
"""

# Typically ignore this.
# pylint: disable=invalid-name

# Disable these because this is our standard setup
# pylint: disable=wildcard-import,unused-wildcard-import,wrong-import-position

import os, sys, copy, time
from datetime import datetime

CIMEROOT = os.environ.get("CIMEROOT")
if CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")
sys.path.append(os.path.join(CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.case import Case
from CIME.nmlgen import NamelistGenerator
from CIME.buildnml import create_namelist_infile, parse_input
from CIME.utils import expect, safe_copy, symlink_force

logger = logging.getLogger(__name__)

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
###############################################################################
def _write_blkdat(nmlgen, out_file, groups, sorted_groups):
###############################################################################
    """Blkdat version of `write` assuming that a file object is input."""

    if groups is None:
        groups = self._groups.keys()

    if (sorted_groups):
        group_names = sorted(group for group in groups)
    else:
        group_names = groups

    # variables for checking vertical layer definition
    nsigma = int(nmlgen.get_value("nsigma"))
    remove_list_a = ["dp00", "dp00x", "dp00f", "ds00", "ds00x", "ds00f"]
    remove_list_b = ["dp0k", "ds0k"]

    lines = []
    for group_name in group_names:
        # allow empty group
        if group_name in nmlgen._namelist._groups:
            group = nmlgen._namelist._groups[group_name]
            for name in sorted(group.keys()):
                values = group[name]
                values = [x.strip("\"") for x in values]
                node = nmlgen._definition.get_child("entry", {"id":name})
                desc = nmlgen._definition.get_description(node)
                vtyp = nmlgen._definition._get_type_info(node)

                # remove specific parameters from namelist
                if nsigma > 0:
                    if name in remove_list_a:
                        continue
                else:
                    if name in remove_list_b:
                        continue                    

                # add item to list
                if 'freeform_a' in group_name: # header
                    if not values[0]:
                        lines.append("{}".format("x"*80))
                    else:
                        title = ", ".join(values)
                        if len(title) > 80:
                            title = ",".join(values)
                            if len(title) > 80:
                                logger.info("The line in title section must be 80 character long! Please check following line:")
                                logger.info(title)
                        lines.append("{}".format(title))
                else: # rest
                    if len(values) > 1:
                        i = 1
                        for x in values:
                            lines.append("{:>7}   '{:<6}' = {}".format(x, name, "layer {:>3} ".format(i)+desc))                 
                            i = i+1
                    else:        
                        strlen = len(values[0])
                        stremp = "{}".format(" "*(4-(strlen-6)))
                        if "logical" in vtyp:
                             lines.append("{:>7}   '{:<6}' = {}".format(0 if ".false." in values[0].strip() else 1, name, desc))
                        else:
                            if strlen > 6:
                                lines.append("{:>{w1}}{w2}'{:<6}' = {}".format(values[0], name, desc, w1=strlen, w2=stremp))
                            else:
                                lines.append("{:>7}   '{:<6}' = {}".format(values[0], name, desc)) 

    # Write namelist file
    with open(out_file, 'w') as namelist:
        for line in lines:
            namelist.write(line+"\n")

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
###############################################################################
def _create_namelist(case, confdir, config, infile, nmlgen):
###############################################################################
    """Write out the namelist for this component.

    Most arguments are the same as those for `NamelistGenerator`.
    The `confdir` argument is used to specify the directory  in which output files will be placed.
    """

    # Input data list 
    data_list_path = os.path.join(case.get_case_root(), "Buildconf", "hycom.input_data_list")

    # Initialize namelist defaults
    nmlgen.init_defaults(infile, config)

    # Path for namelist files
    srcroot = case.get_value("SRCROOT")
    namelist_xml_dir = os.path.join(srcroot, "src", "model", "HYCOM", "cime", "cime_config")

    # Create list of groups by querying xml file
    groups = []
    with open(os.path.join(namelist_xml_dir, "namelist_definition_hycom.xml"), 'r') as fin:
        for s in fin.xreadlines():
            if "<group>" in s:
                groups.append(s.replace('<group>', '').replace('</group>', '').strip())

    # Remove duplicates
    groups = list(set(groups))

    # Create namelist
    namelist_file = os.path.join(confdir, "ocn_in")

    # Write namelist
    _write_blkdat(nmlgen, namelist_file, groups=groups, sorted_groups=True)

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################

    # Build the component namelist
    if compname != "hycom":
        raise AttributeError
    srcroot = case.get_value("SRCROOT")
    rundir  = case.get_value("RUNDIR")

    # Determine the confdir directory
    confdir = os.path.join(caseroot,"Buildconf","hycomconf")
    if not os.path.isdir(confdir):
        os.makedirs(confdir)

    # Determine CaseDocs
    casedocsdir = os.path.join(caseroot,"CaseDocs")

    # Path for namelist file
    namelist_xml_dir = os.path.join(srcroot, "src", "model", "HYCOM", "cime", "cime_config")

    # Set namelist definition file
    definition_file = [os.path.join(namelist_xml_dir, "namelist_definition_hycom.xml")]

    # Create namelist_infile using user_nl_file as input
    user_nl_file = os.path.join(caseroot, "user_nl_hycom")
    expect(os.path.isfile(user_nl_file),
           "Missing required user_nl_file %s " %(user_nl_file))
    infile = os.path.join(confdir, "namelist_infile")
    create_namelist_infile(case, user_nl_file, infile)
    namelist_infile = [infile]

    #--------------------------------------------
    # Namelist generator for HYCOM (blkdat.input) 
    #--------------------------------------------

    # Create config dictionary
    config = {}

    # Create the namelist generator object
    nmlgen = NamelistGenerator(case, definition_file)     

    # Create namelist
    _create_namelist(case, confdir, config, namelist_infile, nmlgen)

    # Copy namelist files to rundir
    if os.path.isdir(rundir):
        file1 = os.path.join(confdir, "ocn_in")
        file2 = os.path.join(rundir, "ocn_in")
        logger.debug("ufsatm namelist copy: file1 %s file2 %s " %(file1, file2))
        safe_copy(file1, file2)

    # Link file
    logger.info("\tLinking input namelist for hycom")
    if not os.path.exists(rundir):
        expect(False, "Couldn't find run direcory " + rundir)
    symlink_force(file2, os.path.join(rundir, "blkdat.input"))

###############################################################################
def _main_func():

    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "hycom")

if __name__ == "__main__":
    _main_func()
